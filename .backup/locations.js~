'use strict';

const _ = require('lodash');
const async = require('async');
const chalk = require('chalk');
const pwdGenerator = require('generate-password');

const User = require('../models/User');
const Location = require('../models/Location');
const Product  = require('../models/Product');
const ProductTemplate = require('../models/ProductTemplate');

module.exports = {
  list: (req, res) => {
    Location.find({}, '_id name', (err, locations) => {
      if(err) {
        console.log(chalk.red("location.list:" ), err);
        //TODO all those kinds of errors should be handled more generic in a single later middleware
        return res.status(500).send({err: "Server error"});
      }

      return res.json(locations);
    });
  },

  get: (req, res, next) => {
    Location.findById(req.params.locationId, (err, data) => {
      if (err)
        return next(err);

      if (!data)
        return res.status(404).json({ msg: 'Location with given id not found'});

      req.location = data;
      return next();
    });
  },

  returnLocation: (req, res) => {
    return res.json(req.location);
  },

  getChefLocation: (req, res, next) => {
    let query = req.params.locationId ? {_id: req.params.locationId} : {chef: res.locals.user._id};
    return Location
      .findOne(query)
      .then((location) => {
        req.location = location;
        return next();
      })
      .catch(next)
  },

  validateCreateReq: (req, res, next) => {
    // validate body
    const requiredAttrs = [
      'name', 'address', 'city', 'zip', 'minProducts', 'hasDaily', 'products', 'chefName', 'email'
    ];
    let attributesFailed = false;
    requiredAttrs.forEach(attr => {
      if (!(attr in req.body)) {
        attributesFailed = true;
        return res.status(400).json({err: `Attr required: ${attr}`});
      }
    });
	console.log(req.body);
    if (attributesFailed)
      return;

    if (req.body.products.length < req.body.minProducts)
      return res.status(400).json({ err: 'Did not provide all required products'});

    User.find({email: req.body.email}, (err, data) => {
      if (err)
        return res.status(500).json({ err: 'Server error' });
      if (data.length > 0)
        return res.status(400).json({ err: 'Chef email already registered' });

      return next();
    });
  },

  create: (req, res, next) => {
    let productsIds = [];
    let chefId = null;

    async.series([
      // create chef
      (dn) => {
        const chefUsr = new User(
          _.assign(
            { role: 'chef', password: pwdGenerator.generate({ length: 10, numbers: true }) },
            _.pick(req.body, ['email', 'chefName']))
        );
        chefUsr.save((err, data) => {
          if (err)
            return dn(err);

          chefId = data._id;
          return dn();
        });
      },
      // create products based on product templates referenced
      (dn) => {
        ProductTemplate.find({'_id': {$in: req.body.products}}, (err, pts) => {
          const products = pts.map(pt => new Product(_.omit(pt, ['_id'])));
          Product.insertMany(products, (err, result) => {
            if (err)
              return dn(err);
            productsIds = _.map(result, '_id');
            dn();
          });
        });
      },
      // create location
      (dn) => {
        const location = new Location(_.pick(req.body,
          ['name', 'address', 'city', 'zip', 'minProducts', 'hasDaily', 'sub', 'subList']));
        location.products = productsIds;
        location.chef = chefId;
        location.save((err) => {
          if (err) {
            console.log(err);
            return dn(err);
          }
          dn();
        });
      },
    ], (err) => {
      //TODO should not get here, but how to do multiple operations differently in Mongo? :)
      if (err)
        return res.status(500).json({err: 'Server error'});

      // send response early
      res.status(201).send({});

      return next();
    });
  },

  sendEmailNotificationToChef: (req, res, next) => {
    //TODO should probably send an email to the chef notifying him of what has happened... implement when necessary
  },



  updatePickupTime : (req, res) => {
    if(!req.body.pickupStart || !req.body.pickupEnd || !req.body.orderDeadline) {
      return res.status(400).send("Request is not correctly formatted");
    }
    let updateObj = { orderDeadline : req.body.orderDeadline, pickupStart: req.body.pickupStart, pickupEnd: req.body.pickupEnd };

    //Ensure that input is valid /TODO currently it just checks the length.. maybe the input should be numbers instead?
    for(var key in updateObj){
      if(updateObj[key].length > 5) {
        return res.status(400).send("Request is not correctly formatted");
      }
    }

    Location.findByIdAndUpdate(req.params.locationId, updateObj)
      .then(location => {
        if (!location) {
          return res.status(400).send("Location not found");
        } else {
          return res.status(200).send({});
        }
      }).catch(err => {
      return res.status(500).send(err.message);
    });
  },

  updateLocation: (req, res) => {
    Location.findByIdAndUpdate(req.params.locationId, req.body)
      .then(location => {
        if (!location) {
          return res.status(400).send("Location not found");
        } else {
          return res.status(200).send({});
        }
      }).catch(err => {
      return res.status(500).send(err.message);
    });
  },
  deleteLocation: (req, res) => {
    Location.findByIdAndRemove(req.params.locationId)
      .then(location => {
        //Delete chef user
        if (location.chef) {
          User.findByIdAndRemove(location.chef)
            .then(chef => {
              console.log(chef);
            })
            .catch(err => {
              console.log(err);
            });
        }
        if (!location)
          return res.status(400).send("Location not found");
        else
          return res.status(200).send({});
      }).catch(err => {
      return res.status(500).send(err.message)
    });
  }
};
